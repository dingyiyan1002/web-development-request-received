# Level 1 - 运算符（8道题）

---

## 题号：057

### 题目信息
- **难度级别**：Level 1 入门
- **标题**：自增运算符前缀与后缀
- **知识标签**：i++、++i、自增运算
- **嵌入式场景**：循环计数，数组索引
- **面试频率**：极高

### 代码
```c
 1 | #include <stdio.h>
 2 | #include <stdint.h>
 3 |
 4 | int main(void)
 5 | {
 6 |     uint8_t a = 5;
 7 |     uint8_t b = 5;
 8 |     uint8_t result1 = 0;
 9 |     uint8_t result2 = 0;
10 |
11 |     result1 = a++;
12 |     result2 = ++b;
13 |
14 |     printf("a=%u, result1=%u\n", a, result1);
15 |     printf("b=%u, result2=%u\n", b, result2);
16 |
17 |     return 0;
18 | }
```

### 提示
a++先使用后自增，++b先自增后使用。

### 内存图
```
执行过程:
  a=5, b=5
  
  result1 = a++:
    先使用a的值: result1 = 5
    再自增: a = 6
  
  result2 = ++b:
    先自增: b = 6
    再使用b的值: result2 = 6

结果: a=6, result1=5, b=6, result2=6
```

### 逐行解析
- 第6-7行：a和b初始值5
- 🔥 第11行：后置++，先赋值5给result1，再a变成6
- 🔥 第12行：前置++，先b变成6，再赋值6给result2
- 第14行：打印a=6, result1=5
- 第15行：打印b=6, result2=6

### 嵌入式Linux实战说明
**工作场景**：循环计数、数组索引、状态递增。理解前缀后缀区别很重要。

**前缀 vs 后缀**：
- ++i：先加再用
- i++：先用再加

**最佳实践**：
- 单独使用时无区别
- 复合表达式中要注意
- 优先用前置++（效率略高）

**面试问法**：a++和++a有什么区别？

### 易错点+变体题
**易错点**：
- 混淆前缀后缀
- 同一表达式中多次自增
- 优先级问题

**变体题**：把result1 = a++改成result1 = ++a，输出是什么？

---

## 题号：058

### 题目信息
- **难度级别**：Level 1 入门
- **标题**：取模运算
- **知识标签**：取模%、余数、循环索引
- **嵌入式场景**：环形缓冲区索引，循环计数
- **面试频率**：高

### 代码
```c
 1 | #include <stdio.h>
 2 | #include <stdint.h>
 3 |
 4 | #define BUF_SIZE  8
 5 |
 6 | int main(void)
 7 | {
 8 |     uint8_t index = 0;
 9 |
10 |     for (uint8_t i = 0; i < 15; i++) {
11 |         index = i % BUF_SIZE;
12 |         printf("i=%u -> index=%u\n", i, index);
13 |     }
14 |
15 |     return 0;
16 | }
```

### 提示
取模运算得到余数，常用于循环索引。

### 内存图
```
取模运算:
  i=0:  0 % 8 = 0
  i=1:  1 % 8 = 1
  ...
  i=7:  7 % 8 = 7
  i=8:  8 % 8 = 0  (循环)
  i=9:  9 % 8 = 1
  ...
  i=14: 14 % 8 = 6

输出15行，索引在0-7循环
```

### 逐行解析
- 第4行：缓冲区大小
- 第8行：索引变量
- 第10行：循环15次
- 🔥 第11行：i % BUF_SIZE得到循环索引
- 第12行：打印i和对应的循环索引

### 嵌入式Linux实战说明
**工作场景**：环形缓冲区、循环队列、LED循环显示。取模实现循环索引。

**取模应用**：
- 环形缓冲区索引
- 循环计数
- 奇偶判断

**注意**：
- 负数取模结果与实现相关
- 除数不能为0

**面试问法**：如何判断一个数是奇数还是偶数？

### 易错点+变体题
**易错点**：
- 负数取模
- 除数为0
- 整数除法丢失精度

**变体题**：把BUF_SIZE改成4，i=14时index是多少？

---

## 题号：059

### 题目信息
- **难度级别**：Level 1 入门
- **标题**：位与运算
- **知识标签**：&运算、位掩码、标志位检测
- **嵌入式场景**：寄存器位检测，标志位判断
- **面试频率**：高

### 代码
```c
 1 | #include <stdio.h>
 2 | #include <stdint.h>
 3 |
 4 | #define FLAG_ERROR    (1U << 0)
 5 | #define FLAG_READY    (1U << 1)
 5 | #define FLAG_BUSY     (1U << 2)
 6 | #define FLAG_COMPLETE (1U << 3)
 7 |
 8 | int main(void)
 9 | {
10 |     uint8_t status = 0x0A;  // 00001010
11 |
12 |     if (status & FLAG_ERROR) {
13 |         printf("Error\n");
14 |     } else {
15 |         printf("No error\n");
16 |     }
17 |
18 |     if (status & FLAG_READY) {
19 |         printf("Ready\n");
20 |     }
21 |
22 |     if (status & FLAG_BUSY) {
23 |         printf("Busy\n");
24 |     }
25 |
26 |     if (status & FLAG_COMPLETE) {
27 |         printf("Complete\n");
28 |     }
29 |
30 |     return 0;
31 | }
```

### 提示
&运算检测特定位是否为1，结果非0表示该位为1。

### 内存图
```
状态位分析:
  status = 0x0A = 00001010
  
  FLAG_ERROR    = 00000001, status & FLAG = 0, 不打印
  FLAG_READY    = 00000010, status & FLAG = 2, 打印"Ready"
  FLAG_BUSY     = 00000100, status & FLAG = 0, 不打印
  FLAG_COMPLETE = 00001000, status & FLAG = 8, 打印"Complete"

输出: "No error" "Ready" "Complete"
```

### 逐行解析
- 第4-7行：定义状态标志位
- 第10行：状态值0x0A = 00001010
- 第12-16行：检测错误位（第0位），为0
- 第18-20行：检测就绪位（第1位），为1
- 第22-24行：检测忙位（第2位），为0
- 第26-28行：检测完成位（第3位），为1

### 嵌入式Linux实战说明
**工作场景**：设备状态检测、错误标志判断、中断标志处理。

**位与运算用途**：
- 检测特定位
- 清除特定位
- 提取位域

**面试问法**：如何判断某个位是否为1？

### 易错点+变体题
**易错点**：
- 忘记&的结果是数值不是布尔值
- 混淆&和&&
- 位号计算错误

**变体题**：把status改成0x05，输出是什么？

---

## 题号：060

### 题目信息
- **难度级别**：Level 1 入门
- **标题**：位或运算设置标志
- **知识标签**：|运算、位设置、|=复合赋值
- **嵌入式场景**：寄存器配置，标志位设置
- **面试频率**：高

### 代码
```c
 1 | #include <stdio.h>
 2 | #include <stdint.h>
 3 |
 4 | #define ENABLE_UART   (1U << 0)
 5 | #define ENABLE_SPI    (1U << 1)
 6 | #define ENABLE_I2C    (1U << 2)
 7 |
 8 | int main(void)
 9 | {
10 |     uint8_t peripheral_en = 0x00;
11 |
12 |     peripheral_en |= ENABLE_UART;
13 |     printf("After UART: 0x%02X\n", peripheral_en);
14 |
15 |     peripheral_en |= ENABLE_SPI;
16 |     printf("After SPI: 0x%02X\n", peripheral_en);
17 |
18 |     peripheral_en |= ENABLE_I2C;
19 |     printf("After I2C: 0x%02X\n", peripheral_en);
20 |
21 |     return 0;
22 | }
```

### 提示
|=运算设置特定位为1，不影响其他位。

### 内存图
```
位设置过程:
  初始: peripheral_en = 0x00 = 00000000
  
  |= ENABLE_UART (00000001):
    00000000 | 00000001 = 00000001 = 0x01
  
  |= ENABLE_SPI (00000010):
    00000001 | 00000010 = 00000011 = 0x03
  
  |= ENABLE_I2C (00000100):
    00000011 | 00000100 = 00000111 = 0x07
```

### 逐行解析
- 第4-6行：定义外设使能位
- 第10行：初始值0
- 🔥 第12行：|=设置UART位，结果0x01
- 第15行：|=设置SPI位，结果0x03
- 第18行：|=设置I2C位，结果0x07

### 嵌入式Linux实战说明
**工作场景**：外设使能配置、中断使能设置、GPIO模式配置。

**位或运算用途**：
- 设置特定位
- 组合多个标志
- 启用功能

**面试问法**：|=和=有什么区别？

### 易错点+变体题
**易错点**：
- 混淆|和||
- 忘记|=是复合赋值
- 位号重叠

**变体题**：在设置I2C后，再加一行peripheral_en |= ENABLE_UART，结果是多少？

---

## 题号：061

### 题目信息
- **难度级别**：Level 1 入门
- **标题**：位异或运算翻转位
- **知识标签**：^运算、位翻转、异或
- **嵌入式场景**：LED翻转，状态切换
- **面试频率**：高

### 代码
```c
 1 | #include <stdio.h>
 2 | #include <stdint.h>
 3 |
 4 | #define LED_PIN  (1U << 2)
 5 |
 6 | int main(void)
 7 | {
 8 |     uint8_t gpio_output = 0x00;
 9 |
10 |     gpio_output ^= LED_PIN;
11 |     printf("Toggle 1: 0x%02X\n", gpio_output);
12 |
13 |     gpio_output ^= LED_PIN;
14 |     printf("Toggle 2: 0x%02X\n", gpio_output);
15 |
16 |     gpio_output ^= LED_PIN;
17 |     printf("Toggle 3: 0x%02X\n", gpio_output);
18 |
19 |     return 0;
20 | }
```

### 提示
异或运算：相同为0，不同为1。^=翻转特定位。

### 内存图
```
异或翻转过程:
  初始: gpio_output = 0x00 = 00000000
  
  ^= LED_PIN (00000100):
    00000000 ^ 00000100 = 00000100 = 0x04 (LED亮)
  
  ^= LED_PIN:
    00000100 ^ 00000100 = 00000000 = 0x00 (LED灭)
  
  ^= LED_PIN:
    00000000 ^ 00000100 = 00000100 = 0x04 (LED亮)

输出: 0x04, 0x00, 0x04 (闪烁效果)
```

### 逐行解析
- 第4行：LED引脚定义
- 第8行：GPIO输出初始值
- 🔥 第10行：异或翻转LED，0→1
- 第13行：异或翻转LED，1→0
- 第16行：异或翻转LED，0→1

### 嵌入式Linux实战说明
**工作场景**：LED闪烁、状态切换、数据加密。

**异或运算特点**：
- A ^ A = 0
- A ^ 0 = A
- 可逆运算

**面试问法**：如何不用临时变量交换两个数？

### 易错点+变体题
**易错点**：
- 混淆^和|
- 忘记异或是可逆的
- 多次翻转结果

**变体题**：把gpio_output初始值改成0x04，三次输出分别是什么？

---

## 题号：062

### 题目信息
- **难度级别**：Level 1 入门
- **标题**：位移运算
- **知识标签**：<<、>>、位移、乘除
- **嵌入式场景**：寄存器配置，数据打包
- **面试频率**：高

### 代码
```c
 1 | #include <stdio.h>
 2 | #include <stdint.h>
 3 |
 4 | int main(void)
 5 | {
 6 |     uint8_t value = 0x05;
 7 |
 8 |     printf("value << 1 = 0x%02X\n", value << 1);
 9 |     printf("value << 2 = 0x%02X\n", value << 2);
10 |     printf("value << 4 = 0x%02X\n", value << 4);
11 |
12 |     uint16_t packed = (value << 8) | value;
13 |     printf("packed = 0x%04X\n", packed);
14 |
15 |     return 0;
16 | }
```

### 提示
左移n位等于乘以2^n，右移n位等于除以2^n。

### 内存图
```
位移运算:
  value = 0x05 = 00000101
  
  value << 1 = 00001010 = 0x0A (乘以2)
  value << 2 = 00010100 = 0x14 (乘以4)
  value << 4 = 01010000 = 0x50 (乘以16)
  
  packed = (0x05 << 8) | 0x05
         = 0x0500 | 0x05
         = 0x0505
```

### 逐行解析
- 第6行：初始值0x05
- 第8行：左移1位，0x0A
- 第9行：左移2位，0x14
- 第10行：左移4位，0x50
- 🔥 第12行：组合成16位数据0x0505

### 嵌入式Linux实战说明
**工作场景**：寄存器配置、数据打包、协议组帧。

**位移运算用途**：
- 乘除法优化
- 位域定位
- 数据打包

**注意**：
- 移位超出类型位数会溢出
- 有符号数右移是算术右移

**面试问法**：左移和右移分别相当于什么运算？

### 易错点+变体题
**易错点**：
- 移位溢出
- 有符号数右移
- 移位数为负或过大

**变体题**：把value改成0x80，value << 1的结果是多少？

---

## 题号：063

### 题目信息
- **难度级别**：Level 1 入门
- **标题**：运算符优先级陷阱
- **知识标签**：优先级、括号、表达式求值
- **嵌入式场景**：复杂条件判断，位操作组合
- **面试频率**：高

### 代码
```c
 1 | #include <stdio.h>
 2 | #include <stdint.h>
 3 |
 4 | int main(void)
 5 | {
 6 |     uint8_t a = 1, b = 2, c = 3;
 7 |
 8 |     uint8_t result1 = a + b * c;
 9 |     uint8_t result2 = (a + b) * c;
10 |
11 |     printf("a + b * c = %u\n", result1);
12 |     printf("(a + b) * c = %u\n", result2);
13 |
14 |     uint8_t x = 0x05;
15 |     uint8_t result3 = x & 0x0F << 1;
16 |     uint8_t result4 = (x & 0x0F) << 1;
17 |
18 |     printf("x & 0x0F << 1 = 0x%02X\n", result3);
19 |     printf("(x & 0x0F) << 1 = 0x%02X\n", result4);
20 |
21 |     return 0;
22 | }
```

### 提示
<<优先级高于&，*优先级高于+。不确定就加括号。

### 内存图
```
优先级分析:
  a + b * c:
    先算 b * c = 6
    再算 a + 6 = 7
  
  (a + b) * c:
    先算 a + b = 3
    再算 3 * c = 9
  
  x & 0x0F << 1:
    先算 0x0F << 1 = 0x1E
    再算 x & 0x1E = 0x05 & 0x1E = 0x04
  
  (x & 0x0F) << 1:
    先算 x & 0x0F = 0x05
    再算 0x05 << 1 = 0x0A
```

### 逐行解析
- 第6行：定义变量
- 第8行：*优先级高于+，先算b*c=6，再+a=7
- 第9行：括号改变优先级，先算a+b=3，再*c=9
- 第15行：<<优先级高于&，先移位再与
- 第16行：括号改变优先级，先与再移位

### 嵌入式Linux实战说明
**工作场景**：复杂表达式容易出错，建议用括号明确意图。

**常见优先级**：
- ! > 算术 > 关系 > && > || > 赋值
- << >> 高于 & ^ |

**最佳实践**：
- 不确定就加括号
- 复杂表达式拆分
- 代码可读性优先

**面试问法**：位运算符和逻辑运算符优先级谁高？

### 易错点+变体题
**易错点**：
- 优先级记错
- 不加括号
- 过于依赖记忆

**变体题**：把x & 0x0F << 1改成x << 1 & 0x0F，结果是多少？

---

## 题号：064

### 题目信息
- **难度级别**：Level 1 入门
- **标题**：逗号运算符
- **知识标签**：逗号运算符、顺序求值
- **嵌入式场景**：for循环多变量，宏定义
- **面试频率**：中

### 代码
```c
 1 | #include <stdio.h>
 2 | #include <stdint.h>
 3 |
 4 | int main(void)
 5 | {
 6 |     uint8_t a = 0;
 7 |     uint8_t b = 0;
 8 |
 9 |     a = (b = 3, b + 2);
10 |     printf("a = %u, b = %u\n", a, b);
11 |
12 |     for (uint8_t i = 0, j = 10; i < j; i++, j--) {
13 |         printf("i=%u, j=%u\n", i, j);
14 |     }
15 |
16 |     return 0;
17 | }
```

### 提示
逗号运算符从左到右求值，返回最右边的值。

### 内存图
```
逗号运算符:
  (b = 3, b + 2):
    先执行 b = 3
    再执行 b + 2 = 5
    返回 5
    a = 5

for循环:
  i=0, j=10: 打印
  i=1, j=9:  打印
  i=2, j=8:  打印
  i=3, j=7:  打印
  i=4, j=6:  打印
  i=5, j=5:  不满足i<j，退出
```

### 逐行解析
- 第6-7行：定义变量
- 🔥 第9行：逗号表达式，先b=3，再返回b+2=5
- 第10行：打印a=5, b=3
- 第12行：for循环多变量初始化和更新
- 第13行：打印i和j

### 嵌入式Linux实战说明
**工作场景**：for循环多变量、宏定义中多步操作。

**逗号运算符特点**：
- 从左到右求值
- 返回最右边值
- 优先级最低

**注意**：
- 函数参数中的逗号不是逗号运算符
- 数组初始化中的逗号不是逗号运算符

**面试问法**：逗号运算符的返回值是什么？

### 易错点+变体题
**易错点**：
- 混淆逗号运算符和分隔符
- 忘记返回最右边值
- 副作用顺序

**变体题**：把(b = 3, b + 2)改成(b + 2, b = 3)，a和b分别是多少？

---

# 完成情况

**Level 1 运算符 8道题已完成**

覆盖知识点：
- ✅ 算术运算和取模%
- ✅ 自增自减（i++和++i）
- ✅ 位运算基础（& | ^ ~ << >>）
- ✅ 赋值运算（|= &= ^=）
- ✅ 运算符优先级陷阱
- ✅ sizeof运算符
- ✅ 逗号运算符
- ✅ 场景：寄存器配置、标志位操作、数据对齐
